<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Telegram 3D Pixel Land</title>
    <style>
        :root {
            --ton-primary: #0088cc;
            --ton-secondary: #17212b;
            --ton-accent: #2b5278;
            --ton-text: #e1e1e1;
            --ton-dark: #0e1621;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--ton-dark);
            color: var(--ton-text);
            overflow: hidden;
            height: 100vh;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: white;
            z-index: 100;
        }

        .info-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(23, 33, 43, 0.9);
            padding: 15px;
            border-top: 1px solid var(--ton-accent);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 10;
        }

        .info-panel.visible {
            transform: translateY(0);
        }

        .info-panel h3 {
            color: var(--ton-primary);
            margin-bottom: 10px;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--ton-text);
            font-size: 18px;
            cursor: pointer;
        }

        .pixel-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background-color: var(--ton-accent);
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .stat-item .label {
            font-size: 12px;
            color: #a1a1a1;
        }

        .stat-item .value {
            font-weight: bold;
        }

        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="loading">Loading 3D World...</div>
    <div id="coordinates">X: 0, Y: 0</div>

    <div id="info-panel" class="info-panel">
        <button class="close-btn" id="close-info">×</button>
        <h3 id="detail-title">Pixel Detayları</h3>
        <div id="detail-content">
            <p>Bir pixel seçiniz.</p>
        </div>
        <div class="pixel-stats" id="detail-stats"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('scene-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI * 0.9;

            // Camera position
            camera.position.set(15, 15, 15);
            controls.update();

            // Create pixel world
            const worldSize = 20;
            const pixelSize = 1;
            const worldHeight = 0.5;
            const cubes = [];

            // Materials
            const materials = {
                land: new THREE.MeshStandardMaterial({ color: 0x3a5f0b, roughness: 0.8 }),
                water: new THREE.MeshStandardMaterial({ color: 0x1a3a5a, roughness: 0.2, metalness: 0.5 }),
                mountain: new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.7 }),
                btc: new THREE.MeshStandardMaterial({ color: 0xf7931a, emissive: 0xf7931a, emissiveIntensity: 0.3 }),
                eth: new THREE.MeshStandardMaterial({ color: 0x627eea, emissive: 0x627eea, emissiveIntensity: 0.3 }),
                ton: new THREE.MeshStandardMaterial({ color: 0x0088cc, emissive: 0x0088cc, emissiveIntensity: 0.5 })
            };

            // Generate world
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    // Determine terrain type
                    let type = 'land';
                    let height = worldHeight;
                    let building = null;
                    
                    // Water areas
                    if (
                        (x > 5 && x < 8 && z > 5 && z < 15) ||
                        (x > 12 && x < 15 && z > 5 && z < 15)
                    ) {
                        type = 'water';
                        height = worldHeight * 0.3;
                    }
                    
                    // Mountains
                    else if (Math.random() > 0.95) {
                        type = 'mountain';
                        height = worldHeight * (2 + Math.random() * 3);
                    }
                    
                    // Special buildings
                    else if (Math.random() > 0.98) {
                        const cryptoTypes = ['btc', 'eth', 'ton'];
                        type = cryptoTypes[Math.floor(Math.random() * cryptoTypes.length)];
                        height = worldHeight * (3 + Math.random() * 2);
                        
                        building = {
                            name: `${type.toUpperCase()} Tower`,
                            value: Math.floor(Math.random() * 1000),
                            type: type
                        };
                    }
                    
                    // Create cube
                    const geometry = new THREE.BoxGeometry(pixelSize, height, pixelSize);
                    const material = materials[type];
                    const cube = new THREE.Mesh(geometry, material);
                    
                    cube.position.set(
                        x * pixelSize - worldSize/2,
                        height/2,
                        z * pixelSize - worldSize/2
                    );
                    
                    // Store data
                    cube.userData = {
                        x: x,
                        z: z,
                        type: type,
                        height: height,
                        building: building
                    };
                    
                    scene.add(cube);
                    cubes.push(cube);
                }
            }

            // Hide loading message
            document.getElementById('loading').style.display = 'none';

            // Raycaster for click detection
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Info panel elements
            const infoPanel = document.getElementById('info-panel');
            const closeInfoBtn = document.getElementById('close-info');
            const detailTitle = document.getElementById('detail-title');
            const detailContent = document.getElementById('detail-content');
            const detailStats = document.getElementById('detail-stats');
            const coordinatesDisplay = document.getElementById('coordinates');

            // Click handler
            function onPointerMove(event) {
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                
                // Update coordinates display
                const worldPos = new THREE.Vector3();
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0, 1, 0)), worldPos);
                
                if (worldPos) {
                    coordinatesDisplay.textContent = `X: ${Math.round(worldPos.x)}, Z: ${Math.round(worldPos.z)}`;
                }
            }

            function onPointerDown(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubes);
                
                if (intersects.length > 0) {
                    const cube = intersects[0].object;
                    const data = cube.userData;
                    
                    // Show info panel
                    detailTitle.textContent = `Pixel (${data.x}, ${data.z})`;
                    
                    let content = '';
                    let stats = '';
                    
                    if (data.building) {
                        content = `
                            <h4>${data.building.name}</h4>
                            <p>This is a special ${data.type.toUpperCase()} building.</p>
                            <p>Value: <strong>${data.building.value} ${data.type.toUpperCase()}</strong></p>
                        `;
                        
                        stats = `
                            <div class="stat-item">
                                <div class="label">Type</div>
                                <div class="value">${data.type.toUpperCase()}</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">Height</div>
                                <div class="value">${data.height.toFixed(1)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">Coordinates</div>
                                <div class="value">${data.x}, ${data.z}</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">Value</div>
                                <div class="value">${data.building.value} ${data.type.toUpperCase()}</div>
                            </div>
                        `;
                    } else {
                        content = `
                            <p>This is a ${data.type} pixel.</p>
                            <p>Height: <strong>${data.height.toFixed(1)}</strong></p>
                        `;
                        
                        stats = `
                            <div class="stat-item">
                                <div class="label">Type</div>
                                <div class="value">${data.type}</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">Height</div>
                                <div class="value">${data.height.toFixed(1)}</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">Coordinates</div>
                                <div class="value">${data.x}, ${data.z}</div>
                            </div>
                        `;
                    }
                    
                    detailContent.innerHTML = content;
                    detailStats.innerHTML = stats;
                    infoPanel.classList.add('visible');
                }
            }

            closeInfoBtn.addEventListener('click', () => {
                infoPanel.classList.remove('visible');
            });

            // Event listeners
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerdown', onPointerDown);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            
            animate();
        });
    </script>
</body>
</html>